##  引用与指针的区别

引用是变量的一个别名，内部实现是**只读指针**
而引用只是一个别名，还是变量本身。对引用进行的任何操作就是对变量本身进行操作，因此以达到修改变量的目的。

联系：引用是变量的别名，可以将引用看做**操作受限的指针**；
区别：
1. 不存在**空引用**。引用必须连接到一块合法的内存，但存在空指针。
2. **一旦引用被初始化为一个对象，就不能被指向到另一个对象**。指针可以在任何时候指向到另一个对象。
3. 引用必须在创建时被初始化。指针可以在任何时间被初始化。


```c++
int m=23,n=13;
int& a=m;
a=12;  	//合法，相当于修改m=12
a=n;	//合法，相当于修改m=13
```

引用使用在源代码级相当于普通的变量一样使用，做函数参数时，内部传递的实际是变量地址
```c++
void foo(int x) { x++; }
void fun(int& x) { x++; }
void bar(int* x) { (*x)++; }

int a=1;
foo(a); // a = 1

a = 1;
int& b = a;
fun(b);	// a = 2

a = 1;
int* p = &a;
bar(p);	// a = 2
```

“sizeof 引用" = 指向变量的大小 ， "sizeof 指针"= 指针本身的大小
```c++
int a = 1;  
int\* p = &a;  
int& r = a;  
cout << sizeof(p) << endl;			// 8  
cout << sizeof(r) << endl;			// 4
```

## C++中有了malloc / free , 为什么还需要 new / delete

  1. malloc与free是C++/C语言的**标准库函数**，new/delete是C++的**运算符**。它们都可用于申请动态内存和释放内存。
  2. 对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。
     对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。
     由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。
     **malloc = 分配内存	new = 分配内存 + 初始化**
  3. 因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。

#### delete 与 delete []

delete ptr 代表用来释放内存，且只用来释放ptr指向的内存。     
delete\[\] rg 用来释放rg指向的内存，还逐一调用数组中每个对象的destructor！
```c++
#include <iostream>  

using namespace std;  
  
class foo  
{  
public:  
    foo()  
    {};  
  
    ~foo()  
    { cout << "destroy foo" << endl; };  
};  
  
int main()  
{  
  foo* a = new foo[3];  
  delete a;  
  // destroy foo
  
  foo* b = new foo[3];  
  delete [] b;  
  // destroy foo
  // destroy foo
  // destroy foo
}
```



## C中变量的存储类型有哪些？

c语言中的存储类型有auto, extern, register, static 四种

1. **extern** (**外部变量声明**)，是指这是一个已在**别的地方定义过**的对象，这里只是对变量的一次重复引用，不会产生新的变量。  
2. **static**    (**静态数据**)，数据存放在**全局数据区**，但**作用域只是本文件函数**中，所以你可以在两个不同的文件函数内部申明同名的static变量，但是 它们是两个不同的全局变量。 如果是定义在函数内，那么该对象具有无链接，函数外不能对其访问。如果是定义在函数外，那么该对象具 有内部链接，其它程序文件不能对其访问  
3. **auto** (**普通局部栈变量**)，是自动存储，这种对象会自动创建和销毁 ，建议这个变量要放在堆栈上面，调用函数时分配内存，函数结束时释放内 存。一般隐藏auto默认为自动存储类别。我们程序都变量大多是自动变量。  
4. **register**  (**寄存器变量**)，请求编译器将这个变量保存在**CPU的寄存器**中，从而加快程序的运行.

## static 和 const
static作用：  
1限制范围(函数,变量只能在本文件中使用)  
2设定变量存储区域(静态存储区域)  **每次调用的初始值为上一次调用的值,调用结束后存储空间不释放;**

const作用：  
声明常量，它不能被修改，它存放在常量区

### 与类的结合
```c++
class A  
{  
public:  
    A(int a);  
    static void print();        // 静态成员函数  
  
private:  
    static int aa;              // 静态数据成员的声明  
    static const int count; 	// 常量静态数据成员（可以在构造函数中初始化）  
    const int bb;               // 常量数据成员  
};  

/* 类中的static变量是属于类的，不属于某个对象，它在整个程序的运行过程中只有一个副本，
因此不能在定义对象时 对变量进行初始化，就是不能用构造函数进行初始化，其正确的初始化方法是：

数据类型 类名::静态数据成员名=值；*/  
int A::aa = 0;                  // 静态成员的定义 + 初始化  

/* 常见静态常量初始化方法 */
const int A::count = 25;        // 静态常量成员定义 + 初始化  

/* 在一个类里建立一个const时，不能给他初值 */
A::A(int a) : bb(a)         	// 常量成员的初始化  
{  
    aa += 1;  
}  
  
void A::print()  
{  
    cout << "count=" << count << endl;  
    cout << "aa=" << aa << endl;  
}
```

### const 与 指针的结合
``` c++
const char *ptr;  // 指向字符常量的指针 ： 指针的值可以变（可以指向新的字符），但是不能通过指针修改对应地址的内容
char const *ptr;  // 作用同上

char * const ptr; // 指向字符的常量指针 ： 指针的值不能变，但是可以通过指针更改地址里的值
```

## struct 与 union
union ( 共用体 )：构造数据类型,也叫联合体  
用途：使几个不同类型的变量共占一段内存(相互覆盖)
**Union的不同成员赋值，将会对其他成员重写，原来成员的值就不存在了**

struct ( 结构体 )：是一种构造类型  
用途： 把不同的数据组合成一个整体——自定义数据类型（struct 可以存储多个成员信息）

### struct 与 union 的大小

#### struct的字节对齐(与class一致)
1. 数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，       
以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组，结构体等      
的整数倍开始(比如int在３２位机为４字节, 则要从４的整数倍地址开始存储),基本类型不包括struct/class/uinon。
2. 结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部"最宽基本类型成员"的整数倍地址开始存储.     
(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储.)。
3. 收尾工作:结构体的总大小,也就是sizeof的结果,.必须是其内部最大成员的"最宽基本类型成员"的整数倍.不足的要补齐.(基本类型不包括struct/class/uinon)。

```c++
struct stExample  
{  
    char a;  
    char b  
    short c;  
    int d;  
}; 

sizeof( struct stExample ) // 8
```

#### 设定对齐状态
```c++
#pragma pack(push) 	// 保存对齐状态
#pragma pack(2)		// 设定为2字节对齐

struct test
{
	char m1;
	double m4;
	int m3;
};

sizeof(test) 		// 14 (1+(1) + 8 + 4 ) 

#pragma pack(pop)	// 恢复对齐状态
```

数据成员放入内存的时候，内存拿出一个内存块来，数据成员们排队一个一个往里放，      
遇到太大的，不是把自己劈成两半，能放多少放多少，而是等下一个内存块过来。        
```c++
struct stExample  
{  
    char a;  
    int b;  
    short c;  
};

class A  
{  
    char a;  
    int b;  
    short c;  
};

sizeof(stExample ) // 12
sizeof(A) // 12
```
![](http://hi.csdn.net/attachment/201101/11/0_12947509584Q03.gif)

#### union的字节对齐
```c++
union x{  
    int a;  
    double b;  
    char s[13];  
};

sizeof(x)	// 16
```
先找出union成员中最大的长度，然后根据"最宽基本类型成员"的整数倍对齐



## class 与 struct 的区别

C++中的struct对C中的struct进行了扩充，它已经不再只是一个包含不同数据类型的数据结构了，它已经获取了太多的功能：  
1. struct能包含成员函数吗？ - 能  
2. struct能继承吗？- 能 
3. struct能实现多态吗？- 能
```c++
struct A  
{  
    int val;  
  
    void fun() { cout << "str" << endl; };  
    void fun(int x) { cout << x << endl; };  
};  
  
struct B:A  
{  
    char s;  
    void fun()  { cout << s << endl; };  
};
```
既然这些它都能实现，那它和class还能有什么区别？

**最本质的一个区别就是成员默认属性和默认继承权限的不同：**     
**若不指明，struct成员的默认属性是public的，class成员的默认属性是private的；**       
**若不指明，struct成员的默认继承权限是public的，class成员的默认继承权限是private的；**



## C/C++程序的内存分区

**其实C和C++的内存分区还是有一定区别的，但此处不作区分：**

1）、栈区（stack）— 由**编译器自动分配释放** ，存放**函数的参数值，局部变量的值**等。其  
操作方式类似于数据结构中的栈。  
2）、堆区（heap） — 一般由**程序员分配释放**， 若程序员不释放，程序结束时可能由OS回  
收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。  
3）、全局区（静态区）（static）—，**全局变量和静态变量**的存储是放在一块的，初始化的  
全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另  
一块区域。 \- 程序结束后由系统释放。  
4）、文字常量区 —**常量字符串**就是放在这里的。 程序结束后由系统释放  
5）、程序代码区—存放**函数体**的二进制代码。

**栈区与堆区的区别：**

1. 堆和栈中的存储内容：
**栈存局部变量、函数参数**等。
**堆存储使用new、malloc申请的变量**等；
2. 申请方式：
栈内存由系统分配，
堆内存由自己申请；
3. 申请后系统的响应：
栈——只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。        
堆——首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，     
寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表 中删除，并将该结点的空间分配给程序；
4. 申请大小的限制：Windows下栈的大小一般是2M，堆的容量较大；
5. 申请效率的比较：栈由系统自动分配，速度较快。堆使用new、malloc等分配，较慢；

总结：**栈区优势在处理效率，堆区优势在于灵活**；

**内存模型：自由区、静态区、动态区；**

根据c/c++对象生命周期不同，c/c++的内存模型有三种不同的内存区域，即：自由存储区，动态区、静态区。

1. 自由存储区：局部非静态变量的存储区域，即平常所说的栈；
2. 动态区： 用new ，malloc分配的内存，即平常所说的堆；
3. 静态区：全局变量，静态变量，字符串常量存在的位置；



## Overload，Override，Overwrite